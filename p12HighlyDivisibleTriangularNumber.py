# The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?
##################################################################################
import termcolor
from math import sqrt, ceil

class HighlyDivisibleTriangularNumber:
    def __init__(self, number_of_divisors):
        self.query_number_of_divisors = number_of_divisors
        self.counter = 1
        self.triangle_number = 0
        self.divisors = list()

    def next_triangle_number(self):
        self.triangle_number += self.counter
        self.counter += 1

    def divisors_number(self):
        sum = 0
        for index in range(min(self.divisors), max(self.divisors) + 1):
            if self.divisors.count(index) != 0:
                sum += self.divisors.count(index) + 1
        return sum

    def search_triangle(self):
        ''''Lento
        Può essere migliorato'''
        while True:
            self.next_triangle_number()
            copy_current_triangle = self.triangle_number
            divisor = 2
            while divisor <= copy_current_triangle:
                if copy_current_triangle % divisor == 0:
                    copy_current_triangle /= divisor
                    self.divisors.append(divisor)
                    divisor = 2
                else:
                    divisor += 1
            if len(self.divisors) != 0:
                
                if self.divisors_number() >= self.query_number_of_divisors:
                    return self.triangle_number
            
            self.divisors.clear()

    def search_number_of_divisors(self):
        '''
        Aggiungere due ogni volta che trovo un divisore
        Fino alla radice quadrata:
        se deivisibile per due lo è anche per il numero diviso due
        '''
        while True:
            self.next_triangle_number()
            counter = 2
            for index in range(2, ceil(sqrt(self.triangle_number))):
                if self.triangle_number % index == 0:
                    counter += 2
            if counter >= self.query_number_of_divisors:
                return self.triangle_number

gigi = HighlyDivisibleTriangularNumber(500)
print(gigi.search_number_of_divisors())
    